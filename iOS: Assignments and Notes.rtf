Assignment 2 - 8/15 


1. Value Type vs. Reference Type

    Value Type: Makes a copy when assigned or passed (like struct and enum).
    Reference Type: Doesn’t copy, it just shares the same instance (like class).

2. Difference Between Classes and Structs

    Class: Reference type, supports inheritance.
    Struct: Value type, no inheritance.

3. When to Use Classes vs. Structs

    Use class when you need inheritance or reference sharing.
    Use struct for simpler data that doesn't need inheritance and can be copied easily.

4. Advantages of Structs Over Classes (or Vice Versa)

    Structs: Faster because of value copying, safer with no shared states.
    Classes: Better for complex models, supports inheritance.

5. What is an Enum?

    An enum is a type that has a set of predefined cases. Like a list of related values you can pick from.

6. Difference Between Raw Values and Associated Values

    Raw Values: Fixed values like enum Direction: String { case up = "UP" }.
    Associated Values: Extra info you attach to each case like case success(message: String).

7. How to Make a Function Optional in a Protocol

    Use @objc before the protocol and add optional before the method, like:

    @obj protocal MyProtocol {
      @obj optional func myFunction()
    }

    
8. What is a Protocol?

    A protocol is like a contract that lists what properties and methods a conforming type should have.

9. What is Inheritance?

    Inheritance means one class can "inherit" properties and methods from another class.

10. Different Types of Inheritance

    Single Inheritance: A class inherits from one parent.
    Multiple Inheritance: Inheriting from multiple classes (not directly supported in Swift).

11. Is Multiple Inheritance Supported in iOS Swift?

    No, Swift doesn’t support multiple inheritance. You can use protocols instead.

12. What are Initializers, and Their Uses?

    Initializers set up your object when it’s created. They give initial values to properties.


Example of 3 Entities with 5 Attributes and 3 Actions

    Car
        Attributes: make, model, year, color, mileage
        Actions: drive(), park(), honk()

    Phone
        Attributes: brand, model, storage, batteryLevel, screenSize
        Actions: call(), text(), browse()

    Book
        Attributes: title, author, pages, genre, publisher
        Actions: read(), bookmarkPage(), rate()


Function to Find Largest Number in Integer Array

func findLargestNumber(in array: [Int]) -> Int? {
    return array.max()
}

Create a Calculator Class with Protocol for Addition, Subtraction, Multiplication, and Division

import UIKit

protocol Calculatable {
    func add(_ a: Double, _ b: Double) -> Double
    func subtract(_ a: Double, _ b: Double) -> Double
    func multiply(_ a: Double, _ b: Double) -> Double
    func divide(_ a: Double, _ b: Double) -> Double?
}

class Calculator: Calculatable {
    func add(_ a: Double, _ b: Double) -> Double {
        return a + b
    }
   
    func subtract(_ a: Double, _ b: Double) -> Double {
        return a - b
    }
   
    func multiply(_ a: Double, _ b: Double) -> Double {
        return a * b
    }
   
    func divide(_ a: Double, _ b: Double) -> Double? {
        return b != 0 ? a / b : nil
    }
}


Explanation:


1. protocol Calculatable:
This is where we define a protocol, which is basically a blueprint for methods a class has to follow. The Calculatable protocol lists four functions: add, subtract, multiply, and divide. Any class that uses this protocol must include these functions.

2. class Calculator: Calculatable:
This is the main class. It follows (or conforms to) the Calculatable protocol, meaning it has to include the add, subtract, multiply, and divide methods.

3. Function Details:

    add(_ a: Double, _ b: Double) -> Double: Adds two numbers.
    subtract(_ a: Double, _ b: Double) -> Double: Subtracts the second number from the first one.
    multiply(_ a: Double, _ b: Double) -> Double: Multiplies the two numbers together.
    divide(_ a: Double, _ b: Double) -> Double?: Divides the first number by the second. Since dividing by zero isn’t allowed, this function returns an optional (meaning it can be nil if the division is invalid).

4. Example Usage: We make a Calculator object called myCalculator. Then, we can use it to add or divide numbers. When dividing by zero, it gives us nil, so the app doesn’t crash.


Assignment 3 - 8/16


1. Difference Between guard let and if let

    if let: Used when you want to unwrap an optional and run code only if it has a value. The rest of the code is nested inside the if block.
    guard let: Also used for unwrapping optionals, but it’s better when you want to exit early if the optional is nil. It’s more of an early exit check.

2. When to Use guard let vs. if let

    Use if let when you only need to do something specific when the optional has a value.
    Use guard let when you want to ensure the optional has a value before continuing, and you need to exit early if it doesn’t.

3. Different Types of Properties

    Stored Properties: These store values in classes or structs.
    Computed Properties: These don’t store values but calculate them when accessed.
    Lazy Properties: These are only calculated once when they’re needed.

4. Difference Between Stored and Computed Properties

    Stored properties hold a value directly.
    Computed properties calculate a value on the fly whenever you access them.

5. When to Use Lazy Properties

    Use them when the property’s value takes a lot of resources to calculate, and you don’t want it to be done until it’s really needed.

6. Advantage of Using Lazy Properties

    They save resources by not initializing until they’re first used.

7. What is a Static Property?

    A static property belongs to the type itself, not instances of the type. All instances share the same static property.

8. What is an Extension?

    Extensions let you add new functionality to existing classes, structs, or enums without modifying their original code.

9. What Makes Extensions Powerful?

    They allow you to add functions, initializers, and computed properties to existing types, even ones you don’t own (like those from the system).

10. Can We Add Properties in Extensions?

    You can only add computed properties, not stored properties, in extensions.

11. Different Access Modifiers

    public: Accessible from anywhere.
    open: Like public, but also allows subclassing outside the module.
    internal: Accessible within the module.
    fileprivate: Accessible within the same file.
    private: Accessible within the same scope.

12. Difference Between public and open

    public: You can use it anywhere, but you can’t subclass it outside the module.
    open: You can use and subclass it anywhere, even outside the module.

13. Difference Between private and fileprivate

    private: Only accessible within the same scope (like a single class).
    fileprivate: Accessible anywhere within the same file.

14. What is the Default Access Modifier?

    The default is internal, meaning the property or method is accessible anywhere within the module.

15. Can We Access Private Variables in Extensions?

    No, private variables are not accessible in extensions. You need to use fileprivate if you want to access them within the same file.

16. What is a Closure?

    A closure is like a function, but you can write it inline. It can capture and store references to variables and constants from the surrounding context.

    Swift Coding Challenges:

    1. Add an Extension Function to Integer Array to Return Even Numbers

    extension Array where Element == Int {
        func evenNumbers() -> [Int] {
            return self.filter { $0 % 2 == 0 }
        }
    }

    // Example usage:
    let numbers = [1, 2, 3, 4, 5, 6]
    print(numbers.evenNumbers())  // Output: [2, 4, 6]

    2. Add an Extension Function to Integer Array to Return Odd Numbers

    extension Array where Element == Int {
        func oddNumbers() -> [Int] {
            return self.filter { $0 % 2 != 0 }
        }
    }

    // Example usage:
    let numbers = [1, 2, 3, 4, 5, 6]
    print(numbers.oddNumbers())  // Output: [1, 3, 5]

    3. Find the 2nd Largest Number in a Given Integer Array

    func secondLargest(in array: [Int]) -> Int? {
        let sortedArray = Array(Set(array)).sorted(by: >)
        return sortedArray.count >= 2 ? sortedArray[1] : nil
    }

    // Example usage:
    let numbers = [1, 5, 2, 8, 8, 3]
    if let secondLargestNumber = secondLargest(in: numbers) {
        print(secondLargestNumber)  // Output: 5
    }

    4. Write a Program to Print Fibonacci Series for Given Input n

    func fibonacciSeries(n: Int) -> [Int] {
        guard n > 0 else { return [] }
        var series = [1, 1]
        while series.count < n {
            let next = series[series.count - 1] + series[series.count - 2]
            series.append(next)
        }
        return Array(series.prefix(n))
    }

    // Example usage:
    let fibSeries = fibonacciSeries(n: 8)
    print(fibSeries)  // Output: [1, 1, 2, 3, 5, 8, 13, 21]


// Tuppple

func getLocation() -> (Double, Double) {
  return (10.4, 11.67)
}

let location = getLocation()

print(location.lat)
print(location.long)

let l1: (lat: Double, long:Double) = ().....not finished

//Dictionary

let user = [String: String]()
let user1: [String: String] = [:]
let user2 = [ "name" : "alex", "age" : "23"]

user2["name"] = "max"

print(user2)

//Points about Dictionary

// Dict are unordered 
// 2. can have key value pairs, will not have duplicate keys

// Set

var names = Set<String>()

// Array 

var names1 = Array<String>()

func removeDuplicates(from array: [String] -> [String]{

var uniqueElements: [String] = []
var seenElements: Set<String> = []

for element in array {

       if !seenElements.contains(element)

}
})

//iOS app states

// there are 5 states 
// 1 not running
// 2 in active
//3. Active
//4. Background
//5. Suspended

// when app is in foreground than it will be either in active or inactive state
// when app is in background than it will be eitehr in Background or suspend state



// Assignment 4 

1. Difference Between Set, Array, and Dictionary

    Array: An array is like a list where items are kept in order. You can have duplicates, and you get to access each item by its position. Think of it like a numbered list:
        Example: ["apple", "banana", "apple"]. Here, "apple" shows up twice and stays in the same order.

    Set: A set is like a collection of unique items that aren’t in any particular order. It automatically removes duplicates for you. You can’t ask for the first or second item because they aren’t in any specific order.
        Example: ["apple", "banana"]. Even if you try to add another "apple," it’s only kept once.

    Dictionary: A dictionary is like a phone book. It has a unique key (like a name) linked to a value (like a phone number). You look things up by the key, not by position.
        Example: ["name": "John", "age": 25]. Here, "name" is a key, and "John" is the value for that key.


2. Counting Characters in a String

func countCharacters(in input: String) -> [Character: Int] {
    var characterCount: [Character: Int] = [:] // Create an empty dictionary to store counts

    for char in input { // Loop through each character in the string
        if let count = characterCount[char] { // If the character is already in the dictionary
            characterCount[char] = count + 1 // Increase the count by 1
        } else {
            characterCount[char] = 1 // If it’s not in the dictionary, add it with a count of 1
        }
    }

    return characterCount // Return the dictionary with character counts
}


Explaination:

We first create a function called countCharacters that takes a string and returns a dictionary. This dictionary will store each character and how many times it appears.

We start by making an empty dictionary because we need somewhere to store the counts.

Then, we loop through each character in the string to check it one by one.

If the character is already in the dictionary, we add 1 to its count.

If the character isn’t in the dictionary yet, we add it with a count of 1 because it’s the first time we see it.

After we finish checking all the characters, we return the dictionary that now shows how many times each character appears.

For example, with the input "abcapplebook", the output will show that there are 2 ‘a’s, 2 ‘b’s, 1 ‘c’, and so on.



Internal - default, no explicit indicator, accessible anywhere in project
Private - Only accessible in current scope
Public - Accessible outside of project, accessible but not inheritable or extendible
Open - Accessible outside of project, inheritable and extendable
File Private - Only accessible in current scope


